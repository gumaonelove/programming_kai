#include <iostream>
#include <iomanip>
#include <string>
#include <fstream>
#include <algorithm>
#include "List.h"

using namespace std;

List::List()
{
    head = nullptr; tail = nullptr; Size = 0;
}

List::~List()
{
    Node* temp{};
    ofstream f("./list.txt");
    if (f.is_open())
    {
        if (head != nullptr)
        {
            temp = head;
            for (int i{ 0 }; i < Size; i++)
            {
                f << temp->name + "; " + temp->offers + "; " + temp->all_offers << endl;
                temp = temp->pNext;
            }
            cout << "***Данные успешно загружены в файл***" << endl;
        }
        else
        {
            cout << "***Список пуст, нечего записывать***" << endl;
            f << "Здесь были бы ваши данные, если бы они в принципе были" << endl;
        }
        f.close();
    }
    else // в случае ошибки открытия файла для записи
    {
        cout << "***Не удалось записать данные в файл***" << endl;
    }
    while (Size) // освобождаем память, очищаем список
    {
        pop_front();
    }
    cout << "***Список успешно очищен***" << endl;
}

void List::Separate(string str, string data[]) // функция для разделения входящей из файла строки по значениям полей
{
    int j { 0 };
    for (int i{0}; i < str.size(); i++) // Итерируемся по строке и посимвольно записываем данные, при встрече с разделителем (;)
    {                                   // начинаем записывать данные в следующую ячейку, так происходит разделение по полям данных
        if (str[i] != '\t') // пропускаем табуляцию
        {
            if (str[i] == ';') // начинаем запись данных следующего поля
            {
                j++;
                continue;
            }
            if (j != 0 and str[i] == ' ') // пропускаем пробелы не в названии ценной бумаги, так как в числах нет пробелов
            {
                continue;
            }
            data[j] += str[i];
        }
    }
}

void List::Add_Data(string data[]) // функция добавления данных в наш список
{
    Node *add = new Node; // создаём новый элемент-структуру
    add->name = data[0]; // заполняем данные и очищаем буферный контейнер данных
    data[0] = "";
    add->offers = data[1];
    data[1] = "";
    add->all_offers = data[2];
    data[2] = "";
    if (head == nullptr) // если список пуст, создаём "голову" и замыкаем саму на себя
    {
        head = tail = add;
        add->pNext = head;
    }
    else // иначе добавляем элемент в конец, замыкаем его на голову и делаем крайним элементом в списке
    {
        add->pNext = head;
        tail->pNext = add;
        tail = add;
    }
    Size++; // увеличиваем переменную, отображающую размер нашего списка
}

void List:: List_input() // функция, объединяющая вспомогательные функции для записи всех элементов из файла в список
{
    ifstream f("./list.txt");
    if (f.is_open()) // если файл для чтения открыт, производим запись
    {
        string str{}; // буферная строка, получаемая из файла
        string data[3]{}; // буферный массив элементов, заполняемый в Separate и используемый в Add_Data
        while (!f.eof()) // пока файл не пуст
        {
            getline(f, str); // получаем строку из файла
            if (str == "") // пропускаем пустые строки
            {
                continue;
            }
            Separate(str, data); // разделяем строку по полям нашей структуры
            Add_Data(data); // записываем данные в соответствующие поля
        }
        f.close(); // обязательно закрываем файл после работы  с ним
    }
    else // иначе возвращаем ошибку
    {
        cout << "Не удалось загрузить список" << endl;
        exit(-1);
    }
}

void List::Show() // функция печати списка в консоль
{
    if (head != nullptr) // если список не пуст
    {
        Node* temp{ head }; // временный элемент-структуры для итерации, далее кастомизация вывода с помощью манипуляторов
        cout << setw(3) << left << '№' << setw(25) << "Название ценной бумаги" << setw(20) << "Кол-во сделок" << "Объём торгов" << endl;
        for (int i{ 0 }; i < Size; i++) // итерация по списку, вывод данных в консоль, использование манипуляторов для кастомизации
        {
            cout << '\n' << setw(3) << left << i + 1 << setw(25) << temp->name << setw(20) << temp->offers << temp->all_offers << endl;
            temp = temp->pNext;
        }
        cout << "\n";
    }
    else // если список пуст, сообщаем об этом
    {
        cout << "Здесь были бы ваши данные, если бы они в принципе были" << endl;
    }
}

void List::pop_front() // функция удаления первого элемента из списка
{
    Node* temp{ head };
    head = head->pNext; // переопределяем голову на следующий элемент
    delete temp; // удаляем первый элемент
    Size--; // уменьшаем переменную, отвечающую за размер нашего списка
}

void List::Set_default() // функция сброса значения всех полей всех элементов списка по умолчанию на Nod Defined (ND)
{
    Node* temp{ head }; // временный элемент для итерации
    for (int i{ 0 }; i < Size; i++) // итерация по списку, переопределние значений на ND
    {
        temp->name = "ND"; temp->offers = "ND"; temp->all_offers = "ND";
        temp = temp->pNext;
    }
    cout << "\nЗначения сброшены по умолчанию\n" << endl;
}

void List::Find_and_count() //  функция подсчёта количества элементов с заданным значением одного из полей
{
    short unsigned int num{}; // определяем, данные какого поля будем искать, с обработкой ошибок ввода
    cout << "\n***Данные из какого поля ищем?***\n1 - Название ценной бумаги\n2 - Кол-во сделок\n3 - Объём торгов" << endl;
    cout << "Ожидание пользовательского ввода: ";
    while (!(cin >> num) || cin.peek() != '\n' || num != 1 and num != 2 and num != 3)
    {
        cin.clear();
        while (cin.get() != '\n');
        cout << "\nОшибка ввода. Введите 1 или 2 или 3: ";
    }
    string str{};
    short unsigned int count{ 0 };
    Node* temp{ head };
    switch (num)    // для каждого поля вызываем свой случай, их отличия незначительные, общий принцип один -
    {               // итерация по списку и поиск соответствия заявленного значения со значением нужного поля структуры
        case 1:
            cout << "\nВведите название ценной бумаги: ";
            if (cin.peek() == '\n') // защита от "съедания" строки для ввода
            {
                cin.get();
            }
            getline(cin, str); // получаем заявленное значение
            for (int i{ 0 }; i < Size; i++) // итерируемся по списку
            {
                if (str == temp->name) // сравниваем на соответствие
                {
                    if (count == 0) // если впервые найден соответсующий элемент, вывод в консоль элементов кастомизации
                    {
                        cout << "\n\t\t***Найденные значения***" << endl;
                        cout << setw(3) << left << '№' << setw(25) << "Название ценной бумаги" << setw(20) << "Кол-во сделок" << "Объём торгов" << endl;
                    }
                    cout << '\n' << setw(3) << left << i + 1 << setw(25) << temp->name << setw(20) << temp->offers << temp->all_offers << endl;
                    count += 1; // вывод найденных элементов и увеличение их счётчика
                }
                temp = temp->pNext;
            }
            break;

        case 2:
            cout << "\nВведите кол-во сделок: ";
            cin >> str;
            for (int i{ 0 }; i < Size; i++) // аналогично итерируемся, кастомизируем вывод и увлечиваем счётчик
            {
                if (str == temp->offers)
                {
                    if (count == 0)
                    {
                        cout << "\n\t\t***Найденные значения***" << endl;
                        cout << setw(3) << left << '№' << setw(25) << "Название ценной бумаги" << setw(20) << "Кол-во сделок" << "Объём торгов" << endl;
                    }
                    cout << '\n' << setw(3) << left << i + 1 << setw(25) << temp->name << setw(20) << temp->offers << temp->all_offers << endl;
                    count += 1;
                }
                temp = temp->pNext;
            }
            break;

        case 3:
            cout << "\nВведите объём торгов: ";
            cin >> str;
            for (int i{ 0 }; i < Size; i++) // аналогично итерируемся, кастомизируем вывод и увлечиваем счётчик
            {
                if (str == temp->all_offers)
                {
                    if (count == 0)
                    {
                        cout << "\n\t\t***Найденные значения***" << endl;
                        cout << setw(3) << left << '№' << setw(25) << "Название ценной бумаги" << setw(20) << "Кол-во сделок" << "Объём торгов" << endl;
                    }
                    cout << '\n' << setw(3) << left << i + 1 << setw(25) << temp->name << setw(20) << temp->offers << temp->all_offers << endl;
                    count += 1;
                }
                temp = temp->pNext;
            }
            break;
    }
    if (count != 0) // если счётчик не равен нулю, выводим его значение
    {
        cout << "\nОбщее количество элементов с заданным значением: " << count << '\n' << endl;
    }
    else // если нет соответсвующих значений, сообщаем об этом
    {
        cout << "\n***Нет элементов с таким значением***\n" << endl;
    }
}

void List::Sort_data() // функция печати данных в отсортированном виде, сам список при этом не сортируется
{
    short unsigned int how{};
    short unsigned int what{};
    Node* arr = new Node [Size]; // создаём массив элементов для дальнейшего использования метода сортировки из algorythm
    Node* temp{ head };
    for (int i{ 0 }; i < Size; i++) // заполняем созданный масив всеми элементами списка
    {
        arr[i] = *temp;
        temp = temp->pNext;
    }
    // определение характера сортировки - по возрастанию или убыванию, с обработкой ошибок пользовательского ввода
    cout << "\n***Как будем сортировать?***\n1 - по возрастанию\n2 - по убыванию\nОжидание пользовательского ввода: ";
    while (!(cin >> how) and cin.peek() != '\n' || how != 1 and how != 2)
    {
        cin.clear();
        while (cin.get() != '\n');
        cout << "\nОшибка ввода, введите 1 или 2: ";
    }
    // определяем, по какому полю будем сортировать, с обработкой ошибок пользовательского ввода
    cout << "\n***Что будем сортировать?***\n1 - название ценной бумаги\n2 - кол-во сделок\n3 - объём торгов\nОжидание пользовательского ввода: ";
    while (!(cin >> what) and cin.peek() != '\n' || what != 1 and what != 2 and what != 3)
    {
        cin.clear();
        while (cin.get() != '\n');
        cout << "\nОшибка ввода, введите 1 или 2 или 3: ";
    }

    switch (what)   // 3 случая для сортировки по значению каждого из трёх полей, ключевой принцип один -
    {               // использование метода сортировки из algorythm
        case 1:
            sort(arr, arr + Size, [](Node& d1, Node& d2) // использование метода сортировки из algorythm
            {
                return d1.name < d2.name; // лямбда-функция-предикат для определения, по какому полю и как сортируем
            });
            break;
        case 2:
            sort(arr, arr + Size, [](Node& d1, Node& d2) // использование метода сортировки из algorythm
            {
                return stoull(d1.offers) < stoull(d2.offers); // лямбда-функция-предикат для определения, по какому полю и как сортируем
            });
            break;
        case 3:
            sort(arr, arr + Size, [](Node& d1, Node& d2) // использование метода сортировки из algorythm
            {
                return stoull(d1.all_offers) < stoull(d2.all_offers); // лямбда-функция-предикат для определения, по какому полю и как сортируем
            });
            break;
    }
    cout << "\n\t***Отсортированные данные***" << endl; // кастомизация вывода отсортированных данных
    cout << setw(3) << left << '№' << setw(25) << "Название ценной бумаги" << setw(20) << "Кол-во сделок" << "Объём торгов" << endl;
    if (how == 1) // если пользователь указал сортировку по возрастанию, выводим значения по возрастанию
    {
        for (int i{ 0 }; i < Size; i++) // итерируемся по отсортированному массиву и выводим значения
        {
            cout << '\n' << setw(3) << left << i + 1 << setw(25) << arr[i].name << setw(20) << arr[i].offers << arr[i].all_offers << endl;
        }
        cout << endl;
    }
    else // если пользователь указал сортировку по убыванию, выводим значения по убыванию
    {
        for (int i{ Size - 1 }, j{1}; i >= 0; i--, j++) // итерируемся по отсортированному массиву и выводим значения
        {
            cout << '\n' << setw(3) << left << j << setw(25) << arr[i].name << setw(20) << arr[i].offers << arr[i].all_offers << endl;
        }
        cout << endl;
    }
    delete [] arr; // освобождаем память после печати всех значений
}

